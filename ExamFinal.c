#pragma config(UART_Usage, UART1, uartUserControl, baudRate115200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    clawLimit,      sensorNone)
#pragma config(Sensor, in2,    lineFollowerRIGHT, sensorReflection)
#pragma config(Sensor, in3,    lineFollowerCENTER, sensorLineFollower)
#pragma config(Sensor, in4,    ,               sensorReflection)
#pragma config(Sensor, in5,    ,               sensorLineFollower)
#pragma config(Sensor, in6,    ,               sensorLineFollower)
#pragma config(Sensor, in7,    lineFollowerLEFT, sensorLineFollower)
#pragma config(Sensor, dgtl6,  sonarSensor,    sensorSONAR_cm)
#pragma config(Sensor, dgtl8,  LIMITSWITCHRIGHT, sensorTouch)
#pragma config(Sensor, dgtl9,  LIMITSWITCHLEFT, sensorTouch)
#pragma config(Sensor, dgtl10, Bumper,         sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )

#pragma config(Motor,  port2,           armMotor,      tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           clawMotor,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port10,          leftMotor,     tmotorVex393HighSpeed_HBridge, PIDControl, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port1,           rightMotor,    tmotorVex393HighSpeed_HBridge, PIDControl, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//BB-UART Serial Information
#define PORT "/dev/ttyO4"
#define BAUDRATE B115200
// GLOBAL VARIABLES
int MOTORPOWER = 100;
char INPUT = '0';
int LIGHTTHRESHOLD = 500;
int ANSWERLINE = 0;
//Flags for navigating lines
bool LINEBEGIN = false;
bool LINEEND = false;
bool COLLISIONDETECTED = false;
bool FRONTFLAG = false;

/* FUNCTIONS */
void liftArm()
{
	while (SensorValue[clawLimit] > 2500){ // claw limit exceeded - dont do anything
		motor[armMotor] = MOTORPOWER;
		if(INPUT == '5'){
			break;
		}
	}
	INPUT = '0';
	motor[armMotor] = 0;
	wait1Msec(250);
}

//Lower arm until it reaches the bottom
void lowerArm(){
	while (SensorValue[clawLimit] < 4090){

		motor[armMotor] = MOTORPOWER;
		if(INPUT == '6'){
			break;
		}
	}
	INPUT = '0';
	motor[armMotor] = 0;
	wait1Msec(250);
}

void driveMotorQuery (int power1, string motor1, int power2, string motor2)
{
	if(FRONTFLAG)
	{
	//moveMotorTarget(
	}
}

//Tasks for robot to run
task findLine()
{
	int numOfLines = 0;
	while (!LINEBEGIN && numOfLines < ANSWERLINE)
	{
		//while we havent found the LineNumber we want, keep moving and recording
	}


}

task followLine()
{
	while(!LINEEND && LINEBEGIN)
	{
		//BELOW TAKEN FROM Triple Sensor Line Tracking.c -- need to fix vars
		// RIGHT sensor sees dark:
		if(SensorValue(lineFollowerRIGHT) >LIGHTTHRESHOLD)
		{
			// counter-steer right:
		//	motor[leftMotor]  = 63;
		//	motor[rightMotor] = 0;
			driveMotorQuery(MOTORPOWER, 'l' , 0, 'r'); // some function that takes inputs and asks the robot to drive.
		}
		// CENTER sensor sees dark:
		if(SensorValue(lineFollowerCENTER) > LIGHTTHRESHOLD)
		{
			// go straight
			motor[leftMotor]  = 63;
			motor[rightMotor] = 63;
		}
		// LEFT sensor sees dark:
		if(SensorValue(lineFollowerLEFT) > LIGHTTHRESHOLD)
		{
			// counter-steer left:
			motor[leftMotor]  = 0;
			motor[rightMotor] = 63;
		}
	}
}
//constantly check sonar sensor and update a flag if there is an object infront
task frontCheck(){
	while(true){
		int sensorCheck = SensorValue[sonarSensor];
		if(sensorCheck > -1 && sensorCheck <= 17){
			FRONTFLAG = true;
		}
		else{
			FRONTFLAG = false;
		}
		wait1Msec(100);
		continue;
	}

}
//Receive data over UART;
task CommLink() {
	while (true)
	{
		INPUT = getChar(uartOne);
		wait1Msec(10);
		continue;
	}
}
//task will be called to resolve a front flag raise event
task avoidObject(){
	while (FRONTFLAG){
		// DO SOME AVOIDANCE MANUEVERS
	}

}


task main()
{
	wait1Msec(2000);
	startTask(CommLink); //start getting input from command - keep listening
	startTask(frontCheck); // handle sonar value

	while (INPUT != '!'){ //this will be a flag to start task answer question
		switch (INPUT) { //behaviour for each answer
		case 'A':  //back left
			break;
		case 'B': //front left

			break;
		case 'C': //front right

			break;
		case 'D': //back right

			break;
		}
	}

}
