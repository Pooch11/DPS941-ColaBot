#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    clawLimit,      sensorPotentiometer)
#pragma config(Sensor, in2,    lineRIGHT,      sensorReflection)
#pragma config(Sensor, in3,    lineFollowerCENTER, sensorLineFollower)
#pragma config(Sensor, in4,    lineLEFT,       sensorReflection)
#pragma config(Sensor, in5,    lineFollowerRIGHT, sensorLineFollower)
#pragma config(Sensor, in6,    lineFollowerLEFT, sensorLineFollower)
#pragma config(Sensor, dgtl6,  sonarSensor,    sensorSONAR_cm)
#pragma config(Sensor, dgtl8,  LIMITSWITCHRIGHT, sensorTouch)
#pragma config(Sensor, dgtl9,  LIMITSWITCHLEFT, sensorTouch)
#pragma config(Sensor, dgtl10, Bumper,         sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           rightMotor,    tmotorVex393HighSpeed_HBridge, PIDControl, encoderPort, I2C_2)
#pragma config(Motor,  port2,           armMotor,      tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           clawMotor,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port10,          leftMotor,     tmotorVex393HighSpeed_HBridge, PIDControl, reversed, encoderPort, I2C_1)
#pragma config(UART_Usage, UART1, uartUserControl, baudRate115200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//BB-UART Serial Information
#define PORT "/dev/ttyO4"
#define BAUDRATE B115200



struct Data
{
	short SonarValue;
	short ArmValue;
	bool Drive;
	bool Back;
	bool ArmDown;
	bool ClawClosed;
	int Batt;
};
int MOTORPOWER = 35;
int CLAWPOWER = 45; //claw electrical power
int ARMPOWER = 35; //arm electrical power
bool frontFlag = false;
bool armUp =false;
bool clawOpen =false;
bool isTurning = false;
char rcvInput  = '0';

Data TxPkt;

void openClaw(){
	wait1Msec(500);
	motor[clawMotor] = CLAWPOWER;
	wait1Msec(650);
	motor[clawMotor] = 0;
}
//Close claw and stop motor
void closeClaw(){
	motor[clawMotor] = -CLAWPOWER;
	wait1Msec(600);
	motor[clawMotor] = 0;
}

void liftArm(){
	while (SensorValue[clawLimit] > 2500){ // claw limit exceeded - dont do anything
		motor[armMotor] = -ARMPOWER - 10;
		if(rcvInput == '5'){
			break;
		}

	}
	rcvInput = '0';
	motor[armMotor] = 0;
	wait1Msec(250);
}

//Lower arm until it reaches the bottom
void lowerArm(){

	while (SensorValue[clawLimit] < 4090){

		motor[armMotor] = ARMPOWER;
		if(rcvInput == '6'){
			break;
		}
	}
	rcvInput = '0';
	motor[armMotor] = 0;
	wait1Msec(250);
}
task frontCheck(){

	while(true){
		int sensorCheck = SensorValue[sonarSensor];
		if(sensorCheck > -1 && sensorCheck <= 16){
			frontFlag = true;
		}
		else{
			frontFlag = false;
		}
		wait1Msec(100);
		continue;
	}

}

task UARTRx() {
	//Receiving Data
	char rcvChar;		//Variable to hold the reciving byte data

	while (true)
	{
		rcvChar = getChar(uartOne);
		rcvInput = rcvChar;
		wait1Msec(3);
		continue;
	}
}


task main()
{
	wait1Msec(2000); // process start
	lowerArm();
	TxPkt.SonarValue = TxPkt.ArmValue = 0;
	TxPkt.Drive = false;
	TxPkt.ArmDown = true;
	TxPkt.ClawClosed = true;
	TxPkt.Back = false;
	TxPkt.Batt = 100;
	startTask(UARTRx);
	startTask(frontCheck);
	//Sending Data
	while(true) {

		switch(rcvInput){
		case '1' :
			if(frontFlag == false){
				rcvInput = '0';
				stopAllMotors();
				isTurning = false;
				if (TxPkt.Drive == true) {
					stopAllMotors();
					TxPkt.Drive = false;
					}else if (TxPkt.Drive == false) {
					TxPkt.Back = false;
					motor[leftMotor] = MOTORPOWER;
					motor[rightMotor] = MOTORPOWER;
					TxPkt.Drive = true;
				}
			}
			break;

		case '2' :
			rcvInput = '0';
			stopAllMotors();
			isTurning = false;
			if (TxPkt.Back == true) {
				stopAllMotors();
				TxPkt.Back = false;
				}else if (TxPkt.Back == false) {
				TxPkt.Drive = false;
				motor[leftMotor] = -MOTORPOWER;
				motor[rightMotor] = -MOTORPOWER;
				TxPkt.Back = true;
			}
			break;
		case '3' :
			rcvInput = '0';
			stopAllMotors();
			TxPkt.Drive = false;

			if(isTurning == false){
				motor[rightMotor] = MOTORPOWER;
				isTurning = true;
				}else if(isTurning == true){
				stopAllMotors();
				isTurning = false;
			}

			break;
		case '4' :
			rcvInput = '0';
			stopAllMotors();
			TxPkt.Drive = false;
			if(isTurning == false){
				motor[leftMotor] = MOTORPOWER;
				isTurning = true;
				}else if(isTurning == true){
				stopAllMotors();
				isTurning = false;
			}

			break;
		case '5' :
			rcvInput = '0';
			stopAllMotors();
			isTurning = false;
		//	TxPkt.Drive = false;

			if(armUp == false){
				liftArm();
				armUp = true;
				}else if(armUp == true){
				motor[armMotor] = 0;
			}

			break;
		case '6' :
			rcvInput = '0';
			stopAllMotors();
			isTurning = false;
		//	TxPkt.Drive = false;

			if(armUp == true){
				lowerArm();
				armUp = false;
			}
			else if(armUp == true){
				motor[armMotor] = 0;
			}

			break;
		case '7' :
			rcvInput = '0';
			stopAllMotors();
			isTurning = false;
		//	TxPkt.Drive = false;
			if(clawOpen == false){
				openClaw();
				clawOpen = true;
				}else{
				closeClaw();
				clawOpen = false;
			}
			break;
		case 'H':
			MOTORPOWER = 80;
			break;
		case 'L':
			MOTORPOWER = 35;
			break;
		default :
			if (frontFlag == true && TxPkt.Drive == true && TxPkt.Back == false){
				stopAllMotors();
				TxPkt.Drive = false;
			}
		}
	}
}
