#pragma config(UART_Usage, UART1, uartUserControl, baudRate115200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1, clawLimit, sensorPotentiometer)
#pragma config(Sensor, in2, lineFollowerLEFT, sensorLineFollower)
#pragma config(Sensor, in3, lineFollowerCENTER, sensorLineFollower)
#pragma config(Sensor, in6, SNOOFER, sensorLineFollower)
#pragma config(Sensor, in7, lineFollowerRIGHT, sensorLineFollower)
#pragma config(Sensor, dgtl6, sonarSensor, sensorSONAR_cm)
#pragma config(Sensor, I2C_1, , sensorQuadEncoderOnI2CPort, , AutoAssign)
#pragma config(Sensor, I2C_2, , sensorQuadEncoderOnI2CPort, , AutoAssign)
#pragma config(Motor, port2, armMotor, tmotorServoContinuousRotation, openLoop)
#pragma config(Motor, port1, rightMotor, tmotorServoContinuousRotation, openLoop)
#pragma config(Motor, port10, leftMotor, tmotorServoContinuousRotation, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#pragma config(Motor,  port1,           rightMotor,    tmotorVex393HighSpeed_HBridge, PIDControl, encoderPort, I2C_2)
//#pragma config(Motor,  port10,          leftMotor,     tmotorVex393HighSpeed_HBridge, PIDControl, reversed, encoderPort, I2C_1)
int LIGHTTHRESHOLD = 2000;
/* surfaces, adding them together, then dividing by 2. */
int MOTORPOWER = 100;
int ticksRight = 0;
int ticksLeft = 0;
bool LINEINFRONT = false;
char ANSWER = '!';
int LINECOUNTER = 0;
bool inside = false;
bool frontFlag = false;
char rcvInput = 'O';
bool RUNNING = false;
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*----------------------------------------------------------------------------------------------------*\
|*                             	    - Triple Sensor Line Tracking -                                   *|
|*                                      ROBOTC on VEX 2.0 CORTEX                                      *|
|*                                                                                                    *|
|*  This program uses 3 VEX Line Follower Sensors to track a black line on a light(er) surface.       *|
|*  There is a two second pause at the beginning of the program.                                      *|
|*                                                                                                    *|
|*                                        ROBOT CONFIGURATION                                         *|
|*    NOTES:                                                                                          *|
|*    1)  Reversing 'rightMotor' (port 2) in the "Motors and Sensors Setup" is needed with the        *|
|*        "Squarebot" mode, but may not be needed for all robot configurations.                       *|
|*    2)  Lighting conditions, line darkness, and surface lightness change from place to place,       *|
|*        so the value of 'threshold' may need to be changed to better suit your environment.         *|
|*                                                                                                    *|
|*    MOTORS & SENSORS:                                                                               *|
|*    [I/O Port]          [Name]              [Type]                [Description]                     *|
|*    Motor  - Port 2     rightMotor          VEX 3-wire module     Right side motor                  *|
|*    Motor  - Port 3     leftMotor           VEX 3-wire module     Left side motor                   *|
|*    Analog - Port 1     lineFollowerRIGHT   VEX Light Sensor      Front-right, facing down          *|
|*    Analog - Port 2     lineFollowerCENTER  VEX Light Sensor      Front-center, facing down         *|
|*    Analog - Port 3     lineFollowerLEFT    VEX Light Sensor      Front-left, facing down           *|
\*-----------------------------------------------------------------------------------------------4246-*/

void liftArm()
{
	while (SensorValue[clawLimit] > 2700)
	{ // claw limit exceeded - dont do anything
		motor[armMotor] = -90;
	}
	motor[armMotor] = 0;
	wait1Msec(250);
}
void lowerArm()
{
	while (SensorValue[clawLimit] < 2800)
	{ // claw limit exceeded - dont do anything
		motor[armMotor] = 50;
	}
	motor[armMotor] = 0;
	wait1Msec(250);
}

void increment()
{
	if (!inside)
	{
		inside = true;
		LINECOUNTER++;
		wait1Msec(50);
	}
}
//+++++++++++++++++++++++++++++++++++++++++++++| MAIN |+++++++++++++++++++++++++++++++++++++++++++++++
task frontCheck()
{

	while (true)
	{
		int sensorCheck = SensorValue[sonarSensor];
		if (sensorCheck > -1 && sensorCheck <= 25)
		{
			frontFlag = true;
		}
		else
		{
			frontFlag = false;
		}
		wait1Msec(100);
		continue;
	}
}

task UARTRx()
{
	//Receiving Data
	char rcvChar; //Variable to hold the reciving byte data

	while (true)
	{
		rcvChar = getChar(uartOne);
		ANSWER = rcvChar;
		wait1Msec(3);
		continue;
	}
}
/*
task SNOOF(){
	while(!LINEINFRONT){
		if(SensorValue[SNOOFER] >= 2000)
		{
			LINEINFRONT = true;
			ANSWERFOUND = false;
			wait1Msec(250);
		}
		else
		{
			if (SensorValue(lineFollowerCENTER) < LIGHTTHRESHOLD && SensorValue(lineFollowerLEFT) < LIGHTTHRESHOLD && SensorValue(lineFollowerRIGHT) < LIGHTTHRESHOLD){
				ANSWERFOUND = true;
			}
		}
	}
}
*/
//task answer(){

void FollowLine()
{
	//while(true){
	while (true) // the line i wanted // maybe linenumber is here too
	{

		if (SensorValue(lineFollowerRIGHT) > LIGHTTHRESHOLD)
		{
			// counter-steer right:
			if (ticksRight < 55)
			{
				ticksRight++;
			}
			ticksLeft = ticksLeft / 2;
			motor[leftMotor] = MOTORPOWER;
			motor[rightMotor] = (MOTORPOWER - ((ticksRight * 3)));
		}
		// CENTER sensor sees dark:
		if (SensorValue(lineFollowerCENTER) > LIGHTTHRESHOLD && SensorValue(lineFollowerLEFT) < LIGHTTHRESHOLD && SensorValue(lineFollowerRIGHT) < LIGHTTHRESHOLD)
		{
			// go straight
			if (ticksLeft > 0)
			{
				ticksLeft = ticksLeft / 2;
			}
			if (ticksRight > 0)
			{
				ticksRight = ticksRight / 2;
			}
			motor[leftMotor] = (MOTORPOWER / 2);
			motor[rightMotor] = (MOTORPOWER / 2);
		}
		// LEFT sensor sees dark:
		if (SensorValue(lineFollowerLEFT) > LIGHTTHRESHOLD)
		{
			ticksRight = ticksRight / 2;
			if (ticksLeft < 55)
			{
				ticksLeft++;
			}
			// counter-steer left:
			motor[leftMotor] = MOTORPOWER - ((ticksLeft * 3));
			motor[rightMotor] = MOTORPOWER;
		}
		if (frontFlag)
		{
			motor[leftMotor] = 0;
			motor[rightMotor] = 0;
		}

		if (frontFlag && ((SensorValue(lineFollowerCENTER) < LIGHTTHRESHOLD && SensorValue(lineFollowerLEFT) < LIGHTTHRESHOLD && SensorValue(lineFollowerRIGHT) < LIGHTTHRESHOLD)))
		{
			motor[leftMotor] = 0;
			motor[rightMotor] = 0;
			liftArm();
			RUNNING = false;
			break;
		}
	}
	//}
}

void findLine()
{
	motor[leftMotor] = MOTORPOWER - 20;
	motor[rightMotor] = MOTORPOWER - 20;

	while (!LINEINFRONT)
	{
		if (frontFlag)
		{
			stopAllMotors();
		}
		else
		{
			motor[leftMotor] = MOTORPOWER - 20;
			motor[rightMotor] = MOTORPOWER - 20;
		}

		if (SensorValue[SNOOFER] > 2000)
		{
			increment();
			if (ANSWER == 'A' && (LINECOUNTER == 3 || LINECOUNTER == 4))
			{
				LINEINFRONT = true;
				motor[rightMotor] = (MOTORPOWER / 2);
				motor[leftMotor] = -(MOTORPOWER / 2);
				wait1Msec(200);
			}
			else if (ANSWER == 'B' && (LINECOUNTER == 1 || LINECOUNTER == 2))
			{
				LINEINFRONT = true;
				motor[rightMotor] = (MOTORPOWER / 2);
				motor[leftMotor] = -(MOTORPOWER / 2);
				wait1Msec(200);
			}
			else if (ANSWER == 'C' && (LINECOUNTER == 1 || LINECOUNTER == 2))
			{
				LINEINFRONT = true;
				motor[leftMotor] = (MOTORPOWER / 2);
				motor[rightMotor] = -(MOTORPOWER / 2);
				wait1Msec(200);
			}
			else if (ANSWER == 'D' && (LINECOUNTER == 3 || LINECOUNTER == 4))
			{
				LINEINFRONT = true;
				motor[leftMotor] = (MOTORPOWER / 2);
				motor[rightMotor] = -(MOTORPOWER / 2);
				wait1Msec(200);
			}
			inside = false;
		}
	}
	FollowLine();
}

task main()
{
	wait1Msec(2000); // The program waits for 2000 milliseconds before continuing.
	lowerArm();
	RUNNING = true;
	//getchar from UART();
	startTask(UARTRx);
	while (RUNNING)
	{
		if (ANSWER == 'A' || ANSWER == 'B' || ANSWER == 'C' || ANSWER == 'D')
		{
			stopTask(UARTRx);
			startTask(frontCheck);
			//startTask(SNOOF);
			//startTask(DriveStraight);
			findLine();
			//startTask(FollowLine);
		}
	}
}